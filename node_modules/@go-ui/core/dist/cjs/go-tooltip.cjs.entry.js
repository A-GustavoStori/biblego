'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-348d3f4f.js');
const floatingUi_dom_esm = require('./floating-ui.dom.esm-bae85b62.js');
const debounce = require('./debounce-7cb0ceca.js');
const uniqueId = require('./uniqueId-93e4ecef.js');

const goTooltipCss = "go-tooltip{--tooltip-bg-color:var(--go-color-primary-800);--tooltip-fg-color:var(--go-color-lightest);--tooltip-padding:0.5rem;--tooltip-radius:var(--radius-2);transition:opacity var(--go-duration-normal) var(--go-timing-function), visibility var(--go-duration-normal) var(--go-timing-function);position:fixed;display:block;visibility:hidden;opacity:0;background-color:var(--tooltip-bg-color);color:var(--tooltip-fg-color);padding:var(--tooltip-padding);border-radius:var(--tooltip-radius);box-shadow:var(--shadow-1);pointer-events:none;font-size:var(--go-size-0);z-index:var(--layer-important)}@media (prefers-reduced-motion: reduce){go-tooltip{transition-duration:0s}}go-tooltip.is-active{visibility:visible;opacity:1;pointer-events:inherit}go-tooltip .tooltip-tail{position:absolute;background:var(--tooltip-bg-color);width:0.375rem;height:0.375rem;transform:rotate(45deg)}";
const GoTooltipStyle0 = goTooltipCss;

const GoTooltip = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.debouncedDetermineMouseOut = debounce.debounce(this.determineMouseOut, 150);
        this.triggerId = undefined;
        this.arrow = false;
        this.inline = false;
        this.placement = 'top';
        this.isActive = false;
    }
    componentWillLoad() {
        // if id attribute is not provided, generate a unique id for the tooltip
        if (!this.el.id) {
            this.el.id = uniqueId.uniqueId('go-tooltip-');
        }
        this.triggerEl = document.querySelector(`#${this.triggerId}`);
    }
    componentDidLoad() {
        if (!this.triggerEl) {
            return;
        }
        this.triggerEl.setAttribute('aria-describedby', this.el.id);
        // add event handlers to triggerEl
        this.triggerEl.addEventListener('mouseenter', () => this.show());
        document.addEventListener('mousemove', (e) => this.debouncedDetermineMouseOut(e));
        this.triggerEl.addEventListener('focusin', () => this.show());
        this.triggerEl.addEventListener('focusout', () => this.hide());
        this.arrowEl = this.el.querySelector('.tooltip-tail');
        this.initialiseTooltip(this.triggerEl, this.el, this.arrowEl);
        // keep watching for changes to the tooltip position
        this.cleanUpAutoUpdate = floatingUi_dom_esm.autoUpdate(this.triggerEl, this.el, debounce.debounce(() => this.initialiseTooltip(this.triggerEl, this.el, this.arrowEl), 300), { animationFrame: true });
        // press esc to hide tooltip
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hide();
            }
        });
    }
    initialiseTooltip(triggerEl, tooltipEl, arrowEl) {
        let middleware = [floatingUi_dom_esm.offset(8), floatingUi_dom_esm.flip(), floatingUi_dom_esm.shift()];
        if (this.arrow) {
            middleware.push(floatingUi_dom_esm.arrow({ element: arrowEl }));
        }
        if (this.inline) {
            middleware.push(floatingUi_dom_esm.inline());
        }
        floatingUi_dom_esm.computePosition(triggerEl, tooltipEl, {
            strategy: 'fixed',
            placement: this.placement,
            middleware,
        }).then(({ x, y, placement, middlewareData }) => {
            Object.assign(this.el.style, {
                left: `${x}px`,
                top: `${y}px`,
            });
            if (this.arrow) {
                // Accessing the data
                const { x: arrowX, y: arrowY } = middlewareData.arrow;
                const staticSide = {
                    top: 'bottom',
                    right: 'left',
                    bottom: 'top',
                    left: 'right',
                }[placement.split('-')[0]];
                Object.assign(arrowEl.style, {
                    left: arrowX != null ? `${arrowX}px` : '',
                    top: arrowY != null ? `${arrowY}px` : '',
                    right: '',
                    bottom: '',
                    [staticSide]: '-3px',
                });
            }
        });
    }
    /**
     * show tooltip
     */
    async show() {
        this.isActive = true;
    }
    /**
     * hide tooltip
     */
    async hide() {
        this.isActive = false;
    }
    determineMouseOut(e) {
        if (!this.isActive) {
            return;
        }
        // check if mouse is outside of the tooltip and the trigger element
        const { x, y } = e;
        const { left, top, right, bottom } = this.el.getBoundingClientRect();
        const { left: triggerLeft, top: triggerTop, right: triggerRight, bottom: triggerBottom } = this.triggerEl.getBoundingClientRect();
        const isOutside = x < left || x > right || y < top || y > bottom;
        const isOutsideTrigger = x < triggerLeft || x > triggerRight || y < triggerTop || y > triggerBottom;
        if (isOutside && isOutsideTrigger) {
            this.hide();
        }
    }
    disconnectedCallback() {
        this.cleanUpAutoUpdate && this.cleanUpAutoUpdate();
    }
    render() {
        const { isActive, arrow } = this;
        return (index.h(index.Host, { key: '55eb8e0d96d24c7da560e58ddc984dc581582ae5', role: "tooltip", class: { 'is-active': isActive }, "aria-hidden": isActive ? 'false' : 'true' }, index.h("slot", { key: 'da4bb428731cdc538d96045060af5ba303e91cc3' }), arrow ? index.h("div", { class: "tooltip-tail" }) : null));
    }
    get el() { return index.getElement(this); }
};
GoTooltip.style = GoTooltipStyle0;

exports.go_tooltip = GoTooltip;

//# sourceMappingURL=go-tooltip.cjs.entry.js.map