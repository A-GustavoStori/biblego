import { r as registerInstance, c as createEvent, h, g as getElement } from './index-a73e6b51.js';
import { i as inheritNonFieldAttrs, b as loadFieldSlots, l as loadFieldProps, f as fieldSlotNames } from './form-7290e89c.js';
import './index-30633753.js';
import { p as parseJsonProp } from './helper-bc7b4586.js';
import { u as uniqueId } from './uniqueId-0b35bc55.js';
import './kebabCase-147fb3bf.js';

/**
 * This file is based on the good work of @smhigley:
 * https://github.com/microsoft/sonder-ui/blob/master/src/components/select/select.tsx
 */
var Keys;
(function (Keys) {
    Keys["Backspace"] = "Backspace";
    Keys["Clear"] = "Clear";
    Keys["Down"] = "ArrowDown";
    Keys["End"] = "End";
    Keys["Enter"] = "Enter";
    Keys["Escape"] = "Escape";
    Keys["Home"] = "Home";
    Keys["Left"] = "ArrowLeft";
    Keys["PageDown"] = "PageDown";
    Keys["PageUp"] = "PageUp";
    Keys["Right"] = "ArrowRight";
    Keys["Space"] = " ";
    Keys["Tab"] = "Tab";
    Keys["Up"] = "ArrowUp";
})(Keys || (Keys = {}));
var MenuActions;
(function (MenuActions) {
    MenuActions[MenuActions["Close"] = 0] = "Close";
    MenuActions[MenuActions["CloseSelect"] = 1] = "CloseSelect";
    MenuActions[MenuActions["First"] = 2] = "First";
    MenuActions[MenuActions["Last"] = 3] = "Last";
    MenuActions[MenuActions["Next"] = 4] = "Next";
    MenuActions[MenuActions["Open"] = 5] = "Open";
    MenuActions[MenuActions["PageDown"] = 6] = "PageDown";
    MenuActions[MenuActions["PageUp"] = 7] = "PageUp";
    MenuActions[MenuActions["Previous"] = 8] = "Previous";
    MenuActions[MenuActions["Select"] = 9] = "Select";
    MenuActions[MenuActions["Space"] = 10] = "Space";
    MenuActions[MenuActions["Type"] = 11] = "Type";
})(MenuActions || (MenuActions = {}));
var TreeActions;
(function (TreeActions) {
    TreeActions[TreeActions["Close"] = 0] = "Close";
    TreeActions[TreeActions["First"] = 1] = "First";
    TreeActions[TreeActions["Last"] = 2] = "Last";
    TreeActions[TreeActions["Next"] = 3] = "Next";
    TreeActions[TreeActions["Open"] = 4] = "Open";
    TreeActions[TreeActions["Previous"] = 5] = "Previous";
    TreeActions[TreeActions["Select"] = 6] = "Select";
    TreeActions[TreeActions["UpLevel"] = 7] = "UpLevel";
})(TreeActions || (TreeActions = {}));
// filter an array of options against an input string
// returns an array of options that begin with the filter string, case-independent
function filterOptions(options = [], filter, exclude = []) {
    let filterString = filter.toLowerCase().trim();
    return options.filter((option) => {
        const matches = option.label.toLowerCase().indexOf(filterString) === 0;
        return matches && exclude.indexOf(option) < 0;
    });
}
// return combobox action from key press
function getActionFromKey(event, menuOpen) {
    const { key, altKey, ctrlKey, metaKey } = event;
    const openKeys = ['ArrowDown', 'ArrowUp', 'Enter', ' ', 'Home', 'End']; // all keys that will open the combo
    // handle opening when closed
    if (!menuOpen && openKeys.includes(key)) {
        return MenuActions.Open;
    }
    // handle typing characters when open or closed
    if (key === Keys.Backspace ||
        key === Keys.Clear ||
        (key.length === 1 && key !== ' ' && !altKey && !ctrlKey && !metaKey)) {
        return MenuActions.Type;
    }
    // handle keys when open
    if (menuOpen) {
        if ((key === Keys.Down && !altKey) || key === Keys.Right) {
            return MenuActions.Next;
        }
        else if (key === Keys.Up && altKey) {
            return MenuActions.CloseSelect;
        }
        else if (key === Keys.Up || key === Keys.Left) {
            return MenuActions.Previous;
        }
        else if (key === Keys.Home) {
            return MenuActions.First;
        }
        else if (key === Keys.End) {
            return MenuActions.Last;
        }
        else if (key === Keys.PageUp) {
            return MenuActions.PageUp;
        }
        else if (key === Keys.PageDown) {
            return MenuActions.PageDown;
        }
        else if (key === Keys.Escape) {
            return MenuActions.Close;
        }
        else if (key === Keys.Enter) {
            return MenuActions.CloseSelect;
        }
        else if (key === Keys.Space) {
            return MenuActions.Space;
        }
    }
}
// return the index of an option from an array of options, based on a search string
// if the filter is multiple iterations of the same letter (e.g "aaa"), then cycle through first-letter matches
function getIndexByLetter(options, filter, startIndex = 0) {
    const orderedOptions = [...options.slice(startIndex), ...options.slice(0, startIndex)];
    const firstMatch = filterOptions(orderedOptions, filter)[0];
    const allSameLetter = (array) => array.every((letter) => letter === array[0]);
    // first check if there is an exact match for the typed string
    if (firstMatch) {
        return options.indexOf(firstMatch);
    }
    // if the same letter is being repeated, cycle through first-letter matches
    else if (allSameLetter(filter.split(''))) {
        const matches = filterOptions(orderedOptions, filter[0]);
        return options.indexOf(matches[0]);
    }
    // if no matches, return -1
    else {
        return -1;
    }
}
// get updated option index
function getUpdatedIndex(current, max, action) {
    switch (action) {
        case MenuActions.First:
            return 0;
        case MenuActions.Last:
            return max;
        case MenuActions.Previous:
            return Math.max(0, current - 1);
        case MenuActions.Next:
            return Math.min(max, current + 1);
        default:
            return current;
    }
}
// check if an element is currently scrollable
function isScrollable(element) {
    return element && element.clientHeight < element.scrollHeight;
}
// ensure given child element is within the parent's visible scroll area
function maintainScrollVisibility(activeElement, scrollParent) {
    const { offsetHeight, offsetTop } = activeElement;
    const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
    const isAbove = offsetTop < scrollTop;
    const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
    if (isAbove) {
        scrollParent.scrollTo(0, offsetTop);
    }
    else if (isBelow) {
        scrollParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
    }
}
/**
 * parse multiple formats of options prop into SelectOption[]
 */
const parseSelectOptions = (options) => {
    try {
        // vue passes array of strings into prop as the result of Array.toString()
        console.log('parseSelectOptions', { options });
        if (typeof options === 'string' && !options.startsWith('[')) {
            options = options.split(',');
        }
        const parsedOptions = parseJsonProp(options);
        if (parsedOptions) {
            // format parsed options into SelectOption[]
            return parsedOptions.map((option) => typeof option === 'string'
                ? {
                    value: option,
                    label: option,
                }
                : option);
        }
    }
    catch (e) {
        console.error(`Couldn't parse options: `, options, { e });
    }
};

const goSelectCss = "go-select{--dd-item-padding-y:0.5rem;--dd-item-padding-x:1rem;--dd-item-padding:var(--dd-item-padding-y) var(--dd-item-padding-x);--dd-item-radius:var(--radius-1);--dd-item-bg:var(--dropdown-bg-color);--dd-item-bg-hover:var(--go-color-neutral-200);--dd-item-bg-selected:var(--go-color-neutral-200);--dd-item-fg:var(--go-color-neutral-900);--dd-item-fg-hover:var(--go-color-darkest);--dd-item-fg-selected:var(--go-color-darkest);--dd-item-bg-disabled:transparent;--dd-item-fg-disabled:var(--go-color-neutral-600);--dd-item-width:100%;--dd-item-line-height:1.5em;--dropdown-width:100%}go-select .combo{width:100%;position:relative}go-select .control-icon{z-index:1}go-select .control{cursor:pointer;display:flex;justify-content:space-between;align-items:center}go-select .control .arrow{height:1.5em;transition:transform var(--go-duration-normal) var(--go-timing-function)}@media (prefers-reduced-motion: reduce){go-select .control .arrow{transition-duration:0s}}go-select .control .arrow.open{transform:rotate(180deg)}go-select go-dropdown{max-height:20rem;overflow:auto;z-index:9}go-select .combo-option{background:none;border:none;text-decoration:none;cursor:pointer;display:block;padding:var(--dd-item-padding);border-radius:var(--dd-item-radius);background:var(--dd-item-bg);color:var(--dd-item-fg);width:var(--dd-item-width);line-height:var(--dd-item-line-height);min-height:calc(2 * var(--dd-item-padding-y) + var(--dd-item-line-height));text-align:start}go-select .combo-option:hover{background:var(--dd-item-bg-hover);color:var(--dd-item-fg-hover)}go-select .combo-option:focus-visible{position:relative;z-index:1;outline:var(--go-focus-outline-width, 2px) solid var(--go-focus-outline-color, #000)}go-select .combo-option[aria-selected]{background:var(--dd-item-bg-selected);color:var(--dd-item-fg-selected);padding-right:2rem;position:relative}go-select .combo-option[aria-selected]::after{border-bottom:0.125rem solid currentColor;border-right:0.125rem solid currentColor;content:\"\";height:1rem;position:absolute;right:1rem;top:50%;transform:translate(0, -50%) rotate(45deg);width:0.5rem}go-select[disabled] .combo-option{background:var(--dd-item-bg-disabled);color:var(--dd-item-fg-disabled)}";
const GoSelectStyle0 = goSelectCss;

const GoSelect = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.goChange = createEvent(this, "gochange", 7);
        this.hasNamedSlot = {};
        this.prefixer = 'go-select-';
        this.controlId = uniqueId(this.prefixer);
        // Prevent menu closing before click completed
        this.ignoreBlur = false;
        this.name = undefined;
        this.label = undefined;
        this.labelId = undefined;
        this.suffixId = undefined;
        this.hintId = undefined;
        this.errorId = undefined;
        this.disabled = undefined;
        this.hint = undefined;
        this.error = undefined;
        this.readonly = undefined;
        this.value = undefined;
        this.options = undefined;
        this.parsedOptions = [];
        this.attrs = undefined;
        this.activeIndex = -1;
        this.open = false;
        this.searchString = undefined;
        this.searchTimeout = undefined;
        this.selectedIndex = undefined;
        this.selectedLabel = '';
        this.dropdownWidth = 'auto';
    }
    async componentWillLoad() {
        this.loadOptions();
        this.attrs = inheritNonFieldAttrs(this, ['options']);
        this.hasNamedSlot = loadFieldSlots(this.el);
        if (this.value) {
            this.loadValue();
        }
    }
    loadOptions() {
        this.parsedOptions = parseSelectOptions(this.options);
    }
    loadValue() {
        this.activeIndex = this.parsedOptions.findIndex((option) => option.value === this.value);
        this.selectOption(this.activeIndex);
    }
    handleDomOnOpen(isOpen) {
        if (isOpen) {
            this.listboxRef.open();
            // adjust dropdown size
            // - we use fixed positioning strategy to make dropdown "break out" of the clipping containers, now we need to calculate dropdown width up opening
            // see https://floating-ui.com/docs/computePosition#strategy
            if (this.inputRef) {
                this.dropdownWidth = `${this.inputRef.offsetWidth}px`;
            }
            if (isScrollable(this.listboxRef) && this.activeOptionRef) {
                maintainScrollVisibility(this.activeOptionRef, this.listboxRef);
            }
        }
        else {
            this.listboxRef.close();
        }
    }
    render() {
        var _a;
        const { parsedOptions, activeIndex, controlId: id, open = false, dropdownWidth, value, readonly, disabled, name, attrs, } = this;
        const fieldProps = loadFieldProps(this);
        const activeId = open ? `${id}-${activeIndex}` : '';
        const controlAttrs = Object.assign({ id,
            name,
            value }, attrs);
        return [
            h("input", { key: 'e0629e8341cc8de396181f3b70984596b1ebba99', type: "hidden", name: name, value: value }),
            h("go-field", Object.assign({ key: 'ecd385c79dbda6b291720128fd9776dea26539ae' }, fieldProps), fieldSlotNames.map((slotName) => {
                if (this.hasNamedSlot[slotName]) {
                    return (h("template", { slot: slotName }, h("slot", { name: slotName })));
                }
            }), h("div", { key: 'd3974d11d05c04d80183f99968d7b79d3a73b854', class: "combo" }, h("div", Object.assign({ key: '11818aed0daf7fbb3f9807fcfcbfca37c9e66aad' }, controlAttrs, { role: "combobox", "aria-activedescendant": activeId, "aria-autocomplete": "none", "aria-haspopup": "listbox", "aria-expanded": `${open}`, "aria-labelledby": `${id} ${id}-value`, "aria-controls": `${id}-listbox`, "aria-disabled": disabled ? 'true' : undefined, "aria-readonly": readonly ? 'true' : undefined, class: "control", id: `${id}-value`, ref: (el) => (this.inputRef = el), tabindex: "0", onBlur: this.onComboBlur.bind(this), onKeyDown: this.onComboKeyDown.bind(this) }), h("span", { key: 'c20c10a5c913fad61b0087a2be026182613cbd1f' }, parsedOptions && ((_a = parsedOptions[activeIndex]) === null || _a === void 0 ? void 0 : _a.label) ? parsedOptions[activeIndex].label : ''), h("svg", { key: '625801aecfeefce95606b7b02cfa62530370ff3f', class: { arrow: true, open }, xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", viewBox: "0 0 24 24" }, h("path", { key: '0c5bbf258fd6d304b1b6e4525e5614ad5df3c448', d: "m6 9 6 6 6-6" }))), h("go-dropdown", { key: '8528d780e281a08017dc05215a2ba728a21851de', disabled: readonly || disabled, "trigger-selector": `#${id}-value`, width: dropdownWidth, onOpened: () => {
                    this.updateMenuState(true);
                }, onClosed: () => {
                    this.updateMenuState(false);
                }, role: "listbox", ref: (el) => (this.listboxRef = el), id: `${id}-listbox` }, parsedOptions &&
                parsedOptions.map((option, i) => {
                    return (h("div", { class: { 'current': this.activeIndex === i, 'combo-option': true }, id: `${id}-${i}`, "aria-selected": this.activeIndex === i ? 'true' : undefined, ref: (el) => {
                            if (this.activeIndex === i) {
                                this.activeOptionRef = el;
                            }
                        }, role: "option", onClick: (e) => {
                            e.stopPropagation();
                            this.onOptionClick(i);
                        }, onMouseDown: this.onOptionMouseDown.bind(this) }, option.label));
                })))),
        ];
    }
    getSearchString(char) {
        // reset typing timeout and start new timeout
        // this allows us to make multiple-letter matches, like a native select
        if (typeof this.searchTimeout === 'number') {
            window.clearTimeout(this.searchTimeout);
        }
        this.searchTimeout = window.setTimeout(() => {
            this.searchString = '';
        }, 500);
        // add most recent letter to saved search string
        this.searchString += char;
        return this.searchString;
    }
    onComboKeyDown(event) {
        if (!this.parsedOptions) {
            return;
        }
        const { key } = event;
        const max = this.parsedOptions.length - 1;
        const action = getActionFromKey(event, this.open);
        switch (action) {
            case MenuActions.Next:
            case MenuActions.Last:
            case MenuActions.First:
            case MenuActions.Previous:
                event.preventDefault();
                return this.onOptionChange(getUpdatedIndex(this.activeIndex, max, action));
            case MenuActions.CloseSelect:
            case MenuActions.Space:
                event.preventDefault();
                this.selectOption(this.activeIndex);
            case MenuActions.Close:
                event.preventDefault();
                return this.updateMenuState(false);
            case MenuActions.Type:
                // this.activeIndex = Math.max(0, getIndexByLetter(this.options, key));
                this.onComboType(key);
            case MenuActions.Open:
                event.preventDefault();
                return this.updateMenuState(true);
        }
    }
    onComboBlur() {
        if (this.ignoreBlur) {
            this.ignoreBlur = false;
            return;
        }
        if (this.open) {
            this.selectOption(this.activeIndex);
            this.updateMenuState(false, false);
        }
    }
    onComboType(letter) {
        // open the listbox if it is closed
        this.updateMenuState(true);
        // find the index of the first matching option
        const searchString = this.getSearchString(letter);
        const searchIndex = getIndexByLetter(this.parsedOptions, searchString, this.activeIndex + 1);
        // if a match was found, go to it
        if (searchIndex >= 0) {
            this.onOptionChange(searchIndex);
        }
    }
    onOptionChange(index) {
        this.activeIndex = index;
    }
    onOptionClick(index) {
        this.onOptionChange(index);
        this.selectOption(index);
        this.updateMenuState(false);
    }
    onOptionMouseDown() {
        this.ignoreBlur = true;
    }
    selectOption(index) {
        if (index < 0) {
            return;
        }
        const selected = this.parsedOptions[index];
        this.selectedLabel = selected.label;
        this.selectedIndex = index;
        this.value = selected.value;
        this.goChange.emit({ value: selected.value });
    }
    updateMenuState(open, callFocus = true) {
        if (open && (this.readonly || this.disabled)) {
            return;
        }
        this.open = open;
        if (callFocus) {
            this.inputRef.focus();
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "options": ["loadOptions"],
        "value": ["loadValue"],
        "open": ["handleDomOnOpen"]
    }; }
};
GoSelect.style = GoSelectStyle0;

export { GoSelect as go_select };

//# sourceMappingURL=go-select.entry.js.map