import { J as JSON5 } from './index-30633753.js';
import { u as uniqueId } from './uniqueId-0b35bc55.js';

/**
 * short hand for matchMedia
 * @param query media query string
 * @returns {MediaQueryList}
 */
function mm(query) {
    return window.matchMedia(query);
}
/**
 * Checks if prefer dark mode
 * @returns {boolean} if user has dark mode set in OS
 */
function prefersDark() {
    return mm('(prefers-color-scheme: dark)').matches;
}
/**
 * Checks if prefers reduced motion
 * @returns {boolean} if user prefers reduced motion
 */
function prefersReducedMotion() {
    return mm('(prefers-reduced-motion: reduce)').matches;
}
function watchDevice(callback) {
    const syncEl = document.createElement('div');
    syncEl.setAttribute('id', 'sync-mq');
    document.body.appendChild(syncEl);
    var observer = new ResizeObserver(function (entries) {
        // get device type from body content
        if (!entries[0]) {
            return;
        }
        const style = getComputedStyle(syncEl, '::before').getPropertyValue('content');
        callback(style.replace(/"/g, ''));
    });
    observer.observe(syncEl);
}

/**
 * Extract attributes set on the an element.
 * @param {HTMLElement} el - The element to check.
 * @param {string[]} [excludes=[]] - A list of attribute names to exclude.
 * @param {boolean} [remove=true] - Remove the attributes after extracting them.
 */
const inheritAttributes = (el, excludes = [], remove = true) => {
    if (!el) {
        return {};
    }
    const attributes = el.attributes;
    let attributeObject = {};
    for (let i = 0; i < attributes.length; i++) {
        const { name, value } = attributes[i];
        // console.log(`${name} = ${value}`);
        if (excludes.indexOf(name) === -1) {
            attributeObject[name] = value;
        }
    }
    if (remove) {
        // remove inherited attributes from el
        for (let key in attributeObject) {
            el.removeAttribute(key);
        }
    }
    return attributeObject;
};
/**
 * @deprecated use $attrs.bind(this)(true|false) in component
 * @param component stencil class instance
 * @param excludes exclude inheriting these attributes (besides class, style, id)
 */
function inheritComponentAttrs(component, excludes = [], remove = true) {
    if (!component.el) {
        warning(`root element not found in component`, component);
    }
    return inheritAttributes(component.el, ['class', 'style', 'id', ...Array.from(excludes)], remove);
}
/**
 * get attributes that are not defined in a components props, without removing them from the host element
 * @returns list of attributes inherited from the host element
 */
function $attrs(removeAttrs = false, elPropName = 'el') {
    const propNames = Object.keys(Object.getPrototypeOf(this));
    return inheritAttributes(this[elPropName], ['class', 'style', 'id', 'data-testid', 'slot', ...propNames], removeAttrs);
}
/**
 * Extract the `id` from target element, then remove the original id attribute
 * @param el target element
 * @returns id specified in target element
 */
function extractId(el) {
    const id = el.id;
    el.removeAttribute('id');
    return id;
}
function hasShadowDom(el) {
    return !!el.shadowRoot && !!el.attachShadow;
}
function hasSlot(el, slotName) {
    return !!el.querySelector('[slot="' + slotName + '"]');
}
// export const clamp = (min: number, n: number, max: number) => {
//   return Math.max(min, Math.min(n, max));
// };
// export const debounce = (func: (...args: any[]) => void, wait = 0) => {
//   let timer: any;
//   return (...args: any[]): any => {
//     clearTimeout(timer);
//     timer = setTimeout(func, wait, ...args);
//   };
// };
const isDarkMode = () => {
    const darkByAttribute = document.documentElement.getAttribute('data-theme') === 'dark' ||
        document.documentElement.getAttribute('color-theme') === 'dark';
    return prefersDark() || darkByAttribute;
};
/*!
 * Get all direct descendant elements that match a selector
 * Dependency: the matches() polyfill: https://vanillajstoolkit.com/polyfills/matches/
 * (c) 2018 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Node}   elem     The element to get direct descendants for
 * @param  {String} selector The selector to match against
 * @return {Array}           The matching direct descendants
 */
function selectDirectChildren(elem, selector) {
    return Array.prototype.filter.call(elem.children, function (child) {
        return child.matches(selector);
    });
}
function warning(...args) {
    console.log(`%c[Go UI warning]`, 'background: #e63a34; color: #fff; font-size: 24px;padding: 8px;');
    console.warn(...args);
}
/**
 * Initialise id props (such as `labelId`, `hintId` etc) in stencil component
 * @param instance stencil component instance
 * @param rootEl stencil `@Element()` prop
 * @param idProps array of prop names such as `labelId` without the `Id` suffix, this array will be used to generate ids and assign them back to the class' props
 * @param prefix prefix for generated ids
 */
function initIdProps(instance, rootEl, idProps, prefix) {
    let id = extractId(rootEl);
    if (!id) {
        id = uniqueId(prefix);
    }
    instance.id = id;
    idProps.forEach((key) => {
        if (!instance[`${key}Id`]) {
            instance[`${key}Id`] = `${id}-${key}`;
        }
    });
}
/**
 * parse json prop passed into a component
 * @param prop {T|string}
 */
function parseJsonProp(prop) {
    if (!prop) {
        return null;
    }
    try {
        return typeof prop === 'string' ? JSON5.parse(prop) : prop;
    }
    catch (e) {
        warning('Could not parse prop', e);
    }
}

export { $attrs as $, inheritComponentAttrs as a, hasSlot as b, isDarkMode as c, initIdProps as d, extractId as e, prefersDark as f, prefersReducedMotion as g, hasShadowDom as h, inheritAttributes as i, watchDevice as j, mm as m, parseJsonProp as p, selectDirectChildren as s, warning as w };

//# sourceMappingURL=helper-bc7b4586.js.map