import { h } from "@stencil/core";
import { fieldSlotNames, inheritNonFieldAttrs, loadFieldSlots, loadFieldProps } from "../../../utils/index";
import { getActionFromKey, getIndexByLetter, getUpdatedIndex, isScrollable, maintainScrollVisibility, MenuActions, parseSelectOptions, } from "./utils";
import { uniqueId } from "lodash-es";
export class GoSelect {
    constructor() {
        this.hasNamedSlot = {};
        this.prefixer = 'go-select-';
        this.controlId = uniqueId(this.prefixer);
        // Prevent menu closing before click completed
        this.ignoreBlur = false;
        this.name = undefined;
        this.label = undefined;
        this.labelId = undefined;
        this.suffixId = undefined;
        this.hintId = undefined;
        this.errorId = undefined;
        this.disabled = undefined;
        this.hint = undefined;
        this.error = undefined;
        this.readonly = undefined;
        this.value = undefined;
        this.options = undefined;
        this.parsedOptions = [];
        this.attrs = undefined;
        this.activeIndex = -1;
        this.open = false;
        this.searchString = undefined;
        this.searchTimeout = undefined;
        this.selectedIndex = undefined;
        this.selectedLabel = '';
        this.dropdownWidth = 'auto';
    }
    async componentWillLoad() {
        this.loadOptions();
        this.attrs = inheritNonFieldAttrs(this, ['options']);
        this.hasNamedSlot = loadFieldSlots(this.el);
        if (this.value) {
            this.loadValue();
        }
    }
    loadOptions() {
        this.parsedOptions = parseSelectOptions(this.options);
    }
    loadValue() {
        this.activeIndex = this.parsedOptions.findIndex((option) => option.value === this.value);
        this.selectOption(this.activeIndex);
    }
    handleDomOnOpen(isOpen) {
        if (isOpen) {
            this.listboxRef.open();
            // adjust dropdown size
            // - we use fixed positioning strategy to make dropdown "break out" of the clipping containers, now we need to calculate dropdown width up opening
            // see https://floating-ui.com/docs/computePosition#strategy
            if (this.inputRef) {
                this.dropdownWidth = `${this.inputRef.offsetWidth}px`;
            }
            if (isScrollable(this.listboxRef) && this.activeOptionRef) {
                maintainScrollVisibility(this.activeOptionRef, this.listboxRef);
            }
        }
        else {
            this.listboxRef.close();
        }
    }
    render() {
        var _a;
        const { parsedOptions, activeIndex, controlId: id, open = false, dropdownWidth, value, readonly, disabled, name, attrs, } = this;
        const fieldProps = loadFieldProps(this);
        const activeId = open ? `${id}-${activeIndex}` : '';
        const controlAttrs = Object.assign({ id,
            name,
            value }, attrs);
        return [
            h("input", { key: 'e0629e8341cc8de396181f3b70984596b1ebba99', type: "hidden", name: name, value: value }),
            h("go-field", Object.assign({ key: 'ecd385c79dbda6b291720128fd9776dea26539ae' }, fieldProps), fieldSlotNames.map((slotName) => {
                if (this.hasNamedSlot[slotName]) {
                    return (h("template", { slot: slotName }, h("slot", { name: slotName })));
                }
            }), h("div", { key: 'd3974d11d05c04d80183f99968d7b79d3a73b854', class: "combo" }, h("div", Object.assign({ key: '11818aed0daf7fbb3f9807fcfcbfca37c9e66aad' }, controlAttrs, { role: "combobox", "aria-activedescendant": activeId, "aria-autocomplete": "none", "aria-haspopup": "listbox", "aria-expanded": `${open}`, "aria-labelledby": `${id} ${id}-value`, "aria-controls": `${id}-listbox`, "aria-disabled": disabled ? 'true' : undefined, "aria-readonly": readonly ? 'true' : undefined, class: "control", id: `${id}-value`, ref: (el) => (this.inputRef = el), tabindex: "0", onBlur: this.onComboBlur.bind(this), onKeyDown: this.onComboKeyDown.bind(this) }), h("span", { key: 'c20c10a5c913fad61b0087a2be026182613cbd1f' }, parsedOptions && ((_a = parsedOptions[activeIndex]) === null || _a === void 0 ? void 0 : _a.label) ? parsedOptions[activeIndex].label : ''), h("svg", { key: '625801aecfeefce95606b7b02cfa62530370ff3f', class: { arrow: true, open }, xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", viewBox: "0 0 24 24" }, h("path", { key: '0c5bbf258fd6d304b1b6e4525e5614ad5df3c448', d: "m6 9 6 6 6-6" }))), h("go-dropdown", { key: '8528d780e281a08017dc05215a2ba728a21851de', disabled: readonly || disabled, "trigger-selector": `#${id}-value`, width: dropdownWidth, onOpened: () => {
                    this.updateMenuState(true);
                }, onClosed: () => {
                    this.updateMenuState(false);
                }, role: "listbox", ref: (el) => (this.listboxRef = el), id: `${id}-listbox` }, parsedOptions &&
                parsedOptions.map((option, i) => {
                    return (h("div", { class: { 'current': this.activeIndex === i, 'combo-option': true }, id: `${id}-${i}`, "aria-selected": this.activeIndex === i ? 'true' : undefined, ref: (el) => {
                            if (this.activeIndex === i) {
                                this.activeOptionRef = el;
                            }
                        }, role: "option", onClick: (e) => {
                            e.stopPropagation();
                            this.onOptionClick(i);
                        }, onMouseDown: this.onOptionMouseDown.bind(this) }, option.label));
                })))),
        ];
    }
    getSearchString(char) {
        // reset typing timeout and start new timeout
        // this allows us to make multiple-letter matches, like a native select
        if (typeof this.searchTimeout === 'number') {
            window.clearTimeout(this.searchTimeout);
        }
        this.searchTimeout = window.setTimeout(() => {
            this.searchString = '';
        }, 500);
        // add most recent letter to saved search string
        this.searchString += char;
        return this.searchString;
    }
    onComboKeyDown(event) {
        if (!this.parsedOptions) {
            return;
        }
        const { key } = event;
        const max = this.parsedOptions.length - 1;
        const action = getActionFromKey(event, this.open);
        switch (action) {
            case MenuActions.Next:
            case MenuActions.Last:
            case MenuActions.First:
            case MenuActions.Previous:
                event.preventDefault();
                return this.onOptionChange(getUpdatedIndex(this.activeIndex, max, action));
            case MenuActions.CloseSelect:
            case MenuActions.Space:
                event.preventDefault();
                this.selectOption(this.activeIndex);
            case MenuActions.Close:
                event.preventDefault();
                return this.updateMenuState(false);
            case MenuActions.Type:
                // this.activeIndex = Math.max(0, getIndexByLetter(this.options, key));
                this.onComboType(key);
            case MenuActions.Open:
                event.preventDefault();
                return this.updateMenuState(true);
        }
    }
    onComboBlur() {
        if (this.ignoreBlur) {
            this.ignoreBlur = false;
            return;
        }
        if (this.open) {
            this.selectOption(this.activeIndex);
            this.updateMenuState(false, false);
        }
    }
    onComboType(letter) {
        // open the listbox if it is closed
        this.updateMenuState(true);
        // find the index of the first matching option
        const searchString = this.getSearchString(letter);
        const searchIndex = getIndexByLetter(this.parsedOptions, searchString, this.activeIndex + 1);
        // if a match was found, go to it
        if (searchIndex >= 0) {
            this.onOptionChange(searchIndex);
        }
    }
    onOptionChange(index) {
        this.activeIndex = index;
    }
    onOptionClick(index) {
        this.onOptionChange(index);
        this.selectOption(index);
        this.updateMenuState(false);
    }
    onOptionMouseDown() {
        this.ignoreBlur = true;
    }
    selectOption(index) {
        if (index < 0) {
            return;
        }
        const selected = this.parsedOptions[index];
        this.selectedLabel = selected.label;
        this.selectedIndex = index;
        this.value = selected.value;
        this.goChange.emit({ value: selected.value });
    }
    updateMenuState(open, callFocus = true) {
        if (open && (this.readonly || this.disabled)) {
            return;
        }
        this.open = open;
        if (callFocus) {
            this.inputRef.focus();
        }
    }
    static get is() { return "go-select"; }
    static get originalStyleUrls() {
        return {
            "$": ["go-select.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["go-select.css"]
        };
    }
    static get properties() {
        return {
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Name of the input field"
                },
                "attribute": "name",
                "reflect": false
            },
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Label of the input field"
                },
                "attribute": "label",
                "reflect": false
            },
            "labelId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "DOM id for label"
                },
                "attribute": "label-id",
                "reflect": false
            },
            "suffixId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "DOM id for suffix"
                },
                "attribute": "suffix-id",
                "reflect": false
            },
            "hintId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "DOM id for hint message"
                },
                "attribute": "hint-id",
                "reflect": false
            },
            "errorId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "DOM id for error"
                },
                "attribute": "error-id",
                "reflect": false
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "If the input is disabled"
                },
                "attribute": "disabled",
                "reflect": false
            },
            "hint": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Hint message for the input"
                },
                "attribute": "hint",
                "reflect": false
            },
            "error": {
                "type": "any",
                "mutable": false,
                "complexType": {
                    "original": "string | boolean",
                    "resolved": "boolean | string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Error state of input, text provided will be shown as error message"
                },
                "attribute": "error",
                "reflect": false
            },
            "readonly": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "If this input is read-only"
                },
                "attribute": "readonly",
                "reflect": false
            },
            "value": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "FieldValue",
                    "resolved": "string",
                    "references": {
                        "FieldValue": {
                            "location": "import",
                            "path": "@/interfaces",
                            "id": "src/interfaces/index.ts::FieldValue"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Value of the input field"
                },
                "attribute": "value",
                "reflect": false
            },
            "options": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "SelectOption[] | string[] | string",
                    "resolved": "SelectOption[] | string | string[]",
                    "references": {
                        "SelectOption": {
                            "location": "import",
                            "path": "@/interfaces",
                            "id": "src/interfaces/index.ts::SelectOption"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Array of options.\nNote:\nSometimes frameworks may incorrectly pass the result of Array.toString() into this prop,\n`go-select` tries to obsorb this issue by trying to do a `split(',')` on the options prop\nif a string is passed in.\nThis means the accepted formats include:\n1. array of objects of type `{label: string, value: string}`\n2. array of strings (e.g. ['Apple', 'Orange', 'Banana'])\n3. string, toString() result of format 2 (i.e. 'Apple,Orange,Banana')\n4. string, option 1 or 2 passed in as string that can be parsed by [JSON5](https://json5.org/)"
                },
                "attribute": "options",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "parsedOptions": {},
            "attrs": {},
            "activeIndex": {},
            "open": {},
            "searchString": {},
            "searchTimeout": {},
            "selectedIndex": {},
            "selectedLabel": {},
            "dropdownWidth": {}
        };
    }
    static get events() {
        return [{
                "method": "goChange",
                "name": "gochange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emit custom event with selected value"
                },
                "complexType": {
                    "original": "GoChangeEventDetail<string>",
                    "resolved": "GoChangeEventDetail<string>",
                    "references": {
                        "GoChangeEventDetail": {
                            "location": "import",
                            "path": "@/interfaces",
                            "id": "src/interfaces/index.ts::GoChangeEventDetail"
                        }
                    }
                }
            }];
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "options",
                "methodName": "loadOptions"
            }, {
                "propName": "value",
                "methodName": "loadValue"
            }, {
                "propName": "open",
                "methodName": "handleDomOnOpen"
            }];
    }
}
//# sourceMappingURL=go-select.js.map
