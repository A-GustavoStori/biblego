/**
 * This file is based on the good work of @smhigley:
 * https://github.com/microsoft/sonder-ui/blob/master/src/components/select/select.tsx
 */
import { parseJsonProp } from "../../../utils/index";
export var Keys;
(function (Keys) {
    Keys["Backspace"] = "Backspace";
    Keys["Clear"] = "Clear";
    Keys["Down"] = "ArrowDown";
    Keys["End"] = "End";
    Keys["Enter"] = "Enter";
    Keys["Escape"] = "Escape";
    Keys["Home"] = "Home";
    Keys["Left"] = "ArrowLeft";
    Keys["PageDown"] = "PageDown";
    Keys["PageUp"] = "PageUp";
    Keys["Right"] = "ArrowRight";
    Keys["Space"] = " ";
    Keys["Tab"] = "Tab";
    Keys["Up"] = "ArrowUp";
})(Keys || (Keys = {}));
export var MenuActions;
(function (MenuActions) {
    MenuActions[MenuActions["Close"] = 0] = "Close";
    MenuActions[MenuActions["CloseSelect"] = 1] = "CloseSelect";
    MenuActions[MenuActions["First"] = 2] = "First";
    MenuActions[MenuActions["Last"] = 3] = "Last";
    MenuActions[MenuActions["Next"] = 4] = "Next";
    MenuActions[MenuActions["Open"] = 5] = "Open";
    MenuActions[MenuActions["PageDown"] = 6] = "PageDown";
    MenuActions[MenuActions["PageUp"] = 7] = "PageUp";
    MenuActions[MenuActions["Previous"] = 8] = "Previous";
    MenuActions[MenuActions["Select"] = 9] = "Select";
    MenuActions[MenuActions["Space"] = 10] = "Space";
    MenuActions[MenuActions["Type"] = 11] = "Type";
})(MenuActions || (MenuActions = {}));
export var TreeActions;
(function (TreeActions) {
    TreeActions[TreeActions["Close"] = 0] = "Close";
    TreeActions[TreeActions["First"] = 1] = "First";
    TreeActions[TreeActions["Last"] = 2] = "Last";
    TreeActions[TreeActions["Next"] = 3] = "Next";
    TreeActions[TreeActions["Open"] = 4] = "Open";
    TreeActions[TreeActions["Previous"] = 5] = "Previous";
    TreeActions[TreeActions["Select"] = 6] = "Select";
    TreeActions[TreeActions["UpLevel"] = 7] = "UpLevel";
})(TreeActions || (TreeActions = {}));
// filter an array of options against an input string
// returns an array of options that begin with the filter string, case-independent
export function filterOptions(options = [], filter, exclude = []) {
    let filterString = filter.toLowerCase().trim();
    return options.filter((option) => {
        const matches = option.label.toLowerCase().indexOf(filterString) === 0;
        return matches && exclude.indexOf(option) < 0;
    });
}
// return an array of exact option name matches from a comma-separated string
export function findMatches(options, search) {
    const labels = search.split(',');
    return labels
        .map((label) => {
        const match = options.filter((option) => label.trim().toLowerCase() === option.label.toLowerCase());
        return match.length > 0 ? match[0] : null;
    })
        .filter((option) => option !== null);
}
// return combobox action from key press
export function getActionFromKey(event, menuOpen) {
    const { key, altKey, ctrlKey, metaKey } = event;
    const openKeys = ['ArrowDown', 'ArrowUp', 'Enter', ' ', 'Home', 'End']; // all keys that will open the combo
    // handle opening when closed
    if (!menuOpen && openKeys.includes(key)) {
        return MenuActions.Open;
    }
    // handle typing characters when open or closed
    if (key === Keys.Backspace ||
        key === Keys.Clear ||
        (key.length === 1 && key !== ' ' && !altKey && !ctrlKey && !metaKey)) {
        return MenuActions.Type;
    }
    // handle keys when open
    if (menuOpen) {
        if ((key === Keys.Down && !altKey) || key === Keys.Right) {
            return MenuActions.Next;
        }
        else if (key === Keys.Up && altKey) {
            return MenuActions.CloseSelect;
        }
        else if (key === Keys.Up || key === Keys.Left) {
            return MenuActions.Previous;
        }
        else if (key === Keys.Home) {
            return MenuActions.First;
        }
        else if (key === Keys.End) {
            return MenuActions.Last;
        }
        else if (key === Keys.PageUp) {
            return MenuActions.PageUp;
        }
        else if (key === Keys.PageDown) {
            return MenuActions.PageDown;
        }
        else if (key === Keys.Escape) {
            return MenuActions.Close;
        }
        else if (key === Keys.Enter) {
            return MenuActions.CloseSelect;
        }
        else if (key === Keys.Space) {
            return MenuActions.Space;
        }
    }
}
// return the index of an option from an array of options, based on a search string
// if the filter is multiple iterations of the same letter (e.g "aaa"), then cycle through first-letter matches
export function getIndexByLetter(options, filter, startIndex = 0) {
    const orderedOptions = [...options.slice(startIndex), ...options.slice(0, startIndex)];
    const firstMatch = filterOptions(orderedOptions, filter)[0];
    const allSameLetter = (array) => array.every((letter) => letter === array[0]);
    // first check if there is an exact match for the typed string
    if (firstMatch) {
        return options.indexOf(firstMatch);
    }
    // if the same letter is being repeated, cycle through first-letter matches
    else if (allSameLetter(filter.split(''))) {
        const matches = filterOptions(orderedOptions, filter[0]);
        return options.indexOf(matches[0]);
    }
    // if no matches, return -1
    else {
        return -1;
    }
}
// get updated option index
export function getUpdatedIndex(current, max, action) {
    switch (action) {
        case MenuActions.First:
            return 0;
        case MenuActions.Last:
            return max;
        case MenuActions.Previous:
            return Math.max(0, current - 1);
        case MenuActions.Next:
            return Math.min(max, current + 1);
        default:
            return current;
    }
}
// check if an element is currently scrollable
export function isScrollable(element) {
    return element && element.clientHeight < element.scrollHeight;
}
// ensure given child element is within the parent's visible scroll area
export function maintainScrollVisibility(activeElement, scrollParent) {
    const { offsetHeight, offsetTop } = activeElement;
    const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
    const isAbove = offsetTop < scrollTop;
    const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
    if (isAbove) {
        scrollParent.scrollTo(0, offsetTop);
    }
    else if (isBelow) {
        scrollParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
    }
}
/**
 * parse multiple formats of options prop into SelectOption[]
 */
export const parseSelectOptions = (options) => {
    try {
        // vue passes array of strings into prop as the result of Array.toString()
        console.log('parseSelectOptions', { options });
        if (typeof options === 'string' && !options.startsWith('[')) {
            options = options.split(',');
        }
        const parsedOptions = parseJsonProp(options);
        if (parsedOptions) {
            // format parsed options into SelectOption[]
            return parsedOptions.map((option) => typeof option === 'string'
                ? {
                    value: option,
                    label: option,
                }
                : option);
        }
    }
    catch (e) {
        console.error(`Couldn't parse options: `, options, { e });
    }
};
//# sourceMappingURL=utils.js.map
