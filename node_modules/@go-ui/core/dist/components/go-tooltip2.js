import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { d as debounce, a as autoUpdate, o as offset, f as flip, s as shift, b as arrow, i as inline, c as computePosition } from './floating-ui.dom.esm.js';
import { u as uniqueId } from './uniqueId.js';

const goTooltipCss = "go-tooltip{--tooltip-bg-color:var(--go-color-primary-800);--tooltip-fg-color:var(--go-color-lightest);--tooltip-padding:0.5rem;--tooltip-radius:var(--radius-2);transition:opacity var(--go-duration-normal) var(--go-timing-function), visibility var(--go-duration-normal) var(--go-timing-function);position:fixed;display:block;visibility:hidden;opacity:0;background-color:var(--tooltip-bg-color);color:var(--tooltip-fg-color);padding:var(--tooltip-padding);border-radius:var(--tooltip-radius);box-shadow:var(--shadow-1);pointer-events:none;font-size:var(--go-size-0);z-index:var(--layer-important)}@media (prefers-reduced-motion: reduce){go-tooltip{transition-duration:0s}}go-tooltip.is-active{visibility:visible;opacity:1;pointer-events:inherit}go-tooltip .tooltip-tail{position:absolute;background:var(--tooltip-bg-color);width:0.375rem;height:0.375rem;transform:rotate(45deg)}";
const GoTooltipStyle0 = goTooltipCss;

const GoTooltip = /*@__PURE__*/ proxyCustomElement(class GoTooltip extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.debouncedDetermineMouseOut = debounce(this.determineMouseOut, 150);
        this.triggerId = undefined;
        this.arrow = false;
        this.inline = false;
        this.placement = 'top';
        this.isActive = false;
    }
    componentWillLoad() {
        // if id attribute is not provided, generate a unique id for the tooltip
        if (!this.el.id) {
            this.el.id = uniqueId('go-tooltip-');
        }
        this.triggerEl = document.querySelector(`#${this.triggerId}`);
    }
    componentDidLoad() {
        if (!this.triggerEl) {
            return;
        }
        this.triggerEl.setAttribute('aria-describedby', this.el.id);
        // add event handlers to triggerEl
        this.triggerEl.addEventListener('mouseenter', () => this.show());
        document.addEventListener('mousemove', (e) => this.debouncedDetermineMouseOut(e));
        this.triggerEl.addEventListener('focusin', () => this.show());
        this.triggerEl.addEventListener('focusout', () => this.hide());
        this.arrowEl = this.el.querySelector('.tooltip-tail');
        this.initialiseTooltip(this.triggerEl, this.el, this.arrowEl);
        // keep watching for changes to the tooltip position
        this.cleanUpAutoUpdate = autoUpdate(this.triggerEl, this.el, debounce(() => this.initialiseTooltip(this.triggerEl, this.el, this.arrowEl), 300), { animationFrame: true });
        // press esc to hide tooltip
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hide();
            }
        });
    }
    initialiseTooltip(triggerEl, tooltipEl, arrowEl) {
        let middleware = [offset(8), flip(), shift()];
        if (this.arrow) {
            middleware.push(arrow({ element: arrowEl }));
        }
        if (this.inline) {
            middleware.push(inline());
        }
        computePosition(triggerEl, tooltipEl, {
            strategy: 'fixed',
            placement: this.placement,
            middleware,
        }).then(({ x, y, placement, middlewareData }) => {
            Object.assign(this.el.style, {
                left: `${x}px`,
                top: `${y}px`,
            });
            if (this.arrow) {
                // Accessing the data
                const { x: arrowX, y: arrowY } = middlewareData.arrow;
                const staticSide = {
                    top: 'bottom',
                    right: 'left',
                    bottom: 'top',
                    left: 'right',
                }[placement.split('-')[0]];
                Object.assign(arrowEl.style, {
                    left: arrowX != null ? `${arrowX}px` : '',
                    top: arrowY != null ? `${arrowY}px` : '',
                    right: '',
                    bottom: '',
                    [staticSide]: '-3px',
                });
            }
        });
    }
    /**
     * show tooltip
     */
    async show() {
        this.isActive = true;
    }
    /**
     * hide tooltip
     */
    async hide() {
        this.isActive = false;
    }
    determineMouseOut(e) {
        if (!this.isActive) {
            return;
        }
        // check if mouse is outside of the tooltip and the trigger element
        const { x, y } = e;
        const { left, top, right, bottom } = this.el.getBoundingClientRect();
        const { left: triggerLeft, top: triggerTop, right: triggerRight, bottom: triggerBottom } = this.triggerEl.getBoundingClientRect();
        const isOutside = x < left || x > right || y < top || y > bottom;
        const isOutsideTrigger = x < triggerLeft || x > triggerRight || y < triggerTop || y > triggerBottom;
        if (isOutside && isOutsideTrigger) {
            this.hide();
        }
    }
    disconnectedCallback() {
        this.cleanUpAutoUpdate && this.cleanUpAutoUpdate();
    }
    render() {
        const { isActive, arrow } = this;
        return (h(Host, { key: '55eb8e0d96d24c7da560e58ddc984dc581582ae5', role: "tooltip", class: { 'is-active': isActive }, "aria-hidden": isActive ? 'false' : 'true' }, h("slot", { key: 'da4bb428731cdc538d96045060af5ba303e91cc3' }), arrow ? h("div", { class: "tooltip-tail" }) : null));
    }
    get el() { return this; }
    static get style() { return GoTooltipStyle0; }
}, [4, "go-tooltip", {
        "triggerId": [1, "trigger-id"],
        "arrow": [4],
        "inline": [4],
        "placement": [1],
        "isActive": [32],
        "show": [64],
        "hide": [64]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["go-tooltip"];
    components.forEach(tagName => { switch (tagName) {
        case "go-tooltip":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, GoTooltip);
            }
            break;
    } });
}
defineCustomElement();

export { GoTooltip as G, defineCustomElement as d };

//# sourceMappingURL=go-tooltip2.js.map